class MapController {
  constructor() {
    /** @type {?OverworldMap} */
    this.overworldMap;
    /** @type {!Map.<number, !GameMap>} */
    this.gameMaps = new Map();
    /** @type {!Set.<!GameMapTile>} */
    this.visibleTiles = new Set();
    this.staticMeshGroup = new THREE.Group();
    this.dynamicMeshGroup = new THREE.Group();
    this.lightGroup = new THREE.Group();
    /** @type {!Array.<!Particle>} */
    this.particles = [];
    /** @type {!Array.<!Creature>} */
    this.creatures = [];
    /** @type {!Array.<!Creature>} */
    this.players = [];
    /** @type {Creature} */
    this.active;
    /** @type {!Set.<!Creature>} */
    this.turnTaken = new Set();
    /** @type {!Array.<?Item>} */
    this.inventory = [];
    /** @type {!Set.<number>} */
    this.deathLedger = new Set();
    /** @type {!Set.<number>} */
    this.reviveLedger = new Set();
    for (let i = 0; i < mechInventoryWidth * mechInventoryHeight; i++) {
      this.inventory.push(null);
    }
    this.inCombat = false;
    this.cameraAngle = 0;
  }

  /**
   * @param {!Array.<!Creature>} players
   * @param {number=} optGenLimit
   */
  generateNew(players, optGenLimit) {
    /**
     * @param {function((function(string))=):T} genFn
     * @param {string} identifier
     * @return {T}
     * @template T
     */
    const generateWrapper = (genFn, identifier) => {
      if (optGenLimit) {
        const errors = new Map();
        const logFn = (error) => {
          errors.set(error, (errors.get(error) || 0) + 1);
        };
        const value = genFn(logFn);
        if (value.tiles.size == 0) {
          console.log('--WARNING: Failed to generate ' + identifier + ':');
          for (const error of errors.keys()) {
            console.log('  ' + errors.get(error) + 'x: ' + error);
          }
        }
        return value;
      } else {
        return genFn();
      }
    };

    // Generate the overworld.
    this.overworldMap = generateWrapper((logFn) => {
      return new OverworldMap(generateSeed(), optGenLimit, logFn);
    }, 'overworld map');

    // Generate all of the maps, as a first pass-through.
    this.gameMaps.clear();
    for (const i of this.overworldMap.tiles.keys()) {
      this.gameMaps.set(i, generateWrapper((logFn) => {
        const tile = this.overworldMap.tiles.get(i);
        return new GameMap(tile, optGenLimit, logFn);
      }, 'game map #' + i));
    }

    // Move the player to the start position.
    this.players = players;
    for (const gameMap of this.gameMaps.values()) {
      if (!gameMap.startI) continue;
      for (const player of this.players) {
        this.pickNewSpotFor(player, toX(gameMap.startI), toY(gameMap.startI));
      }
      break;
    }
    this.active = this.players[0];

    // Generate and distribute items.
    this.overworldMap.generateLoot(defaultRNG());
    for (const i of this.overworldMap.tiles.keys()) {
      const gameMap = this.gameMaps.get(i);
      const tile = this.overworldMap.tiles.get(i);
      gameMap.distributeLoot(tile, defaultRNG());
    }

    // Generate all encounters.
    let encounterTally = 1;
    let deathLedgerId = 1;
    for (const i of this.overworldMap.tiles.keys()) {
      const gameMap = this.gameMaps.get(i);
      const tile = this.overworldMap.tiles.get(i);
      for (let j = 0; ; j++) {
        if (j >= 100) {
          // Too many failures... start over from the start!
          this.generateNew(players, optGenLimit);
          return;
        }
        const enemies = gameMap.generateEncounters(
            tile, defaultRNG(), encounterTally);
        if (enemies) {
          for (const enemy of enemies) {
            enemy.deathLedgerId = deathLedgerId++;
            this.addCreature(enemy);
            encounterTally = Math.max(encounterTally, enemy.encounterId + 1);

            // Before adding the creature to the map's ledger, set its EXP to 0
            // temporarily. This ensures that you can't grind by killing and
            // respawning the same enemy over and over.
            const oldEXP = enemy.exp;
            enemy.exp = 0;
            gameMap.enemyRecords.set(enemy.deathLedgerId, enemy.saveString);
            enemy.exp = oldEXP;
          }
          break;
        }
      }
    }

    // Assign EXP to enemies. EXP is divvied out by map level.
    for (let level = 1; level <= mechMaxLevel; level++) {
      const exp = mechNumPlayers * expForNextLevel(level);

      // Get all enemies that were generated by maps of the appropriate level.
      const enemies = [];
      for (const cr of this.creatures) {
        if (cr.player) continue;
        const gameMap = this.gameMapAt(cr.x, cr.y);
        if (!gameMap) continue;
        const overworldMapTile = this.overworldMap.tiles.get(toI(
            gameMap.overworldX, gameMap.overworldY));
        if (!overworldMapTile || overworldMapTile.level != level) continue;
        enemies.push(cr);
      }

      let totalGenerationPoints = 0;
      for (const cr of enemies) {
        totalGenerationPoints += cr.generationPoints;
      }
      for (const cr of enemies) {
        cr.exp = Math.ceil(exp * cr.generationPoints / totalGenerationPoints);
      }
    }
  }

  load() {
    // Pull the last "true save".
    saveManager.pullSave();

    const save = saveManager.loadSaveObj('game');
    if (!save) return;
    const seed = saveManager.intFromSaveObj(save, 'seed');
    this.overworldMap = new OverworldMap(seed);
    // Does not load the game maps yet. They will be loaded in the first
    // "reloadMaps" call. EXCEPT for the map the players are in, of course.
    for (let i = 0; ; i++) {
      const raw = save['player' + i];
      if (!raw) break;
      const player = Creature.load(raw);
      this.players.push(player);
      if (player.dead) continue; // Don't bother adding to map...
      this.loadGameMap(this.overworldIFor_(player.x, player.y));
      this.addCreature(player);
    }
    this.active = this.players[0];
    if (save['dLedger']) {
      this.deathLedger =
          new Set(save['dLedger'].split(',').map((s) => parseInt(s, 10)));
    }
    if (save['rLedger']) {
      this.deathLedger =
          new Set(save['rLedger'].split(',').map((s) => parseInt(s, 10)));
    }
    for (let i = 0; i < this.inventory.length; i++) {
      const saveString = save['i' + i];
      if (!saveString) continue;
      this.inventory[i] = Item.load(saveString);
    }
  }

  revive() {
    // Transfer everything in the death ledger to the revive ledger, so that
    // when we load a map we know to respawn that enemy.
    for (const deathLedgerId of this.deathLedger) {
      this.reviveLedger.add(deathLedgerId);
    }
    this.deathLedger.clear();

    // Also respawn any enemies inside currently-loaded maps.
    for (const gameMap of this.gameMaps.values()) {
      this.reviveForMap_(gameMap);
    }
  }

  /**
   * @param {!GameMap} gameMap
   * @private
   */
  reviveForMap_(gameMap) {
    for (const deathLedgerId of gameMap.enemyRecords.keys()) {
      if (!this.reviveLedger.has(deathLedgerId)) continue;
      const record = gameMap.enemyRecords.get(deathLedgerId);
      this.reviveLedger.delete(deathLedgerId);

      // Revive that record as close to it's original position as possible.
      const creature = Creature.load(record);
      this.pickNewSpotFor(creature, creature.x, creature.y);
    }
  }

  /** Save everything currently loaded into memory. */
  save() {
    const save = {};
    saveManager.intToSaveObj(save, 'seed', this.overworldMap.seed);
    for (let i = 0; i < this.players.length; i++) {
      save['player' + i] = this.players[i].saveString;
    }
    save['dLedger'] = Array.from(this.deathLedger).join(',');
    save['rLedger'] = Array.from(this.reviveLedger).join(',');
    for (let i = 0; i < this.inventory.length; i++) {
      const item = this.inventory[i];
      if (!item) continue;
      save['i' + i] = item.saveString;
    }
    for (const gameMap of this.gameMaps.values()) {
      this.saveGameMap_(gameMap);
    }
    saveManager.save('game', JSON.stringify(save));

    // Since this is a true save, push the save and make it persist!
    saveManager.pushSave();
  }

  /**
   * @param {!GameMap} gameMap
   * @private
   */
  saveGameMap_(gameMap) {
    const i = toI(gameMap.overworldX, gameMap.overworldY);
    const overworldMapTile = this.overworldMap.tiles.get(i);
    const save = {};
    saveManager.intToSaveObj(save, 'seed', overworldMapTile.seed);
    const creaturesToSave = new Set();
    /**
     * @param {string} name
     * @param {!Set.<number>} takeFrom
     */
    const saveLocalIList = (name, takeFrom) => {
      if (takeFrom.size == 0) return;
      save[name] = Array.from(takeFrom).map((i) => {
        // Convert to map-space to make it a little smaller.
        const x = toX(i) - gameMap.xOff;
        const y = toY(i) - gameMap.yOff;
        return toI(x, y);
      }).join(',');
    };
    saveLocalIList('discovered', gameMap.discoveredTileIs);
    for (const tile of gameMap.tiles.values()) {
      if (tile.item) {
        save['i' + toI(tile.x, tile.y)] = tile.item.saveString;
      }
      for (const creature of tile.creatures) {
        if (creature.player) {
          if (this.players.includes(creature)) continue;
        }
        creaturesToSave.add(creature);
      }
    }
    for (const ledgerId of gameMap.enemyRecords.keys()) {
      save['er-' + ledgerId] = gameMap.enemyRecords.get(ledgerId);
    }
    const creaturesToSaveAr = Array.from(creaturesToSave);
    for (let i = 0; i < creaturesToSaveAr.length; i++) {
      save['c' + i] = creaturesToSaveAr[i].saveString;
    }
    saveManager.save('map-' + i, JSON.stringify(save));
  }

  /** @param {number} i */
  loadGameMap(i) {
    if (this.gameMaps.has(i)) return; // No need!
    const save = saveManager.loadSaveObj('map-' + i);
    const tile = this.overworldMap.tiles.get(i);
    if (save) tile.seed = saveManager.intFromSaveObj(save, 'seed');
    const gameMap = new GameMap(tile);
    this.gameMaps.set(i, gameMap);
    /**
     * @param {string} name
     * @param {!Set.<number>} addTo
     */
    const loadLocalIList = (name, addTo) => {
      if (!save[name]) return;
      for (const iStr of save[name].split(',')) {
        // Convert back from map-space.
        const i = parseInt(iStr, 10);
        const x = toX(i) + gameMap.xOff;
        const y = toY(i) + gameMap.yOff;
        addTo.add(toI(x, y));
      }
    };
    loadLocalIList('discovered', gameMap.discoveredTileIs);
    for (const key in save) {
      if (!key.startsWith('er-')) continue;
      gameMap.enemyRecords.set(parseInt(key.replace('er-', ''), 10), save[key]);
    }
    for (let i = 0; ; i++) {
      const saveString = save['c' + i];
      if (!saveString) break;
      const creature = Creature.load(saveString);
      this.addCreature(creature);
    }
    for (const tile of gameMap.tiles.values()) {
      // Clear any items made in generation (e.g. keys, campfires, etc).
      // In case they got used up.
      tile.item = null;
      // Then load whatever was saved.
      const saveString = save['i' + toI(tile.x, tile.y)];
      if (saveString) {
        tile.item = Item.load(saveString);
      }
    }
    this.reviveForMap_(gameMap);
  }

  pickNewActive() {
    if (this.active) this.turnTaken.add(this.active);
    this.active = null;
    for (const creature of this.creatures) {
      if (creature.encounterId) continue;
      if (this.turnTaken.has(creature)) continue;
      if (this.active) {
        if (this.active.getModifiedInitiative() >=
            creature.getModifiedInitiative()) continue;
      }
      this.active = creature;
    }
  }

  /**
   * Note this function assumes the creature is not in a tile already
   * e.g. it was dead before, for example.
   * @param {!Creature} creature
   * @param {number} aroundX
   * @param {number} aroundY
   * @return {boolean}
   */
  pickNewSpotFor(creature, aroundX, aroundY) {
    let bestD = Infinity;
    let bestIs = [];
    const explore = (x, y, d, oldTile) => {
      if (oldTile) {
        const doorId = oldTile.doorIds.get(toI(x, y));
        if (doorId != 0) return; // Can't go through walls!
      }
      const tile = this.tileAt(x, y);
      if (!tile) return;
      if (tile.creatures.length == 0 && !tile.item) {
        if (d < bestD) bestIs = [];
        if (d <= bestD) {
          bestIs.push(toI(x, y));
          bestD = d;
        }
      }
      if (d >= 3) return; // Don't look too far!
      explore(x + 1, y, d + 1, tile);
      explore(x - 1, y, d + 1, tile);
      explore(x, y + 1, d + 1, tile);
      explore(x, y - 1, d + 1, tile);
    };
    explore(aroundX, aroundY, 0, null);
    if (bestIs.length == 0) return false;
    const i = getRandomArrayEntry(bestIs);
    creature.x = toX(i);
    creature.y = toY(i);
    this.addCreature(creature);
    return true;
  }

  rest() {
    for (const player of this.players) {
      if (player.dead) {
        this.pickNewSpotFor(player, this.active.x, this.active.y);
      }
      player.refill();
    }
    this.cleanCreatures();
  }

  /** Remove status effects from all creatures, etc. */
  cleanCreatures() {
    const oldCreatures = this.creatures;
    this.creatures = [];
    for (const creature of oldCreatures) {
      // Save and load to clear status effects.
      creature.removeFromTiles(this);
      if (creature.summonOwner) continue; // Get rid of summons, instead.
      const saveString = creature.saveString;
      const freshCopy = Creature.load(saveString);
      this.addCreature(freshCopy);

      // Be sure for the player array to have it!
      if (freshCopy.player) {
        const idx = this.players.indexOf(creature);
        if (idx != -1) {
          this.players[idx] = freshCopy;
        }
      }
      if (this.active == creature) this.active = freshCopy;
    }

    if (!this.inCombat) {
      // The active player cannot be dead, out of combat.
      const i = this.players.findIndex((c) => !c.dead);
      if (i > 0) {
        this.active = this.players[i];
        [this.players[0], this.players[i]] = [this.players[i], this.players[0]];
      }
    }
  }

  /** @return {boolean} */
  get animating() {
    for (const particle of this.particles) {
      if (particle.blocking) return true;
    }
    for (const creature of this.creatures) {
      if (creature.animating) return true;
    }
    return false;
  }

  /**
   * @param {!Creature} creature
   * @private
   */
  awardEXPFor_(creature) {
    // Award that EXP to all players, evenly distributed among them.
    const livingPlayers = this.players.filter((p) => !p.dead);
    for (const player of livingPlayers) {
      player.awardEXP(Math.ceil(creature.exp / livingPlayers.length));
    }
    creature.exp = 0;
  }

  /** @param {number} elapsed */
  update(elapsed) {
    let creatureDead = false;
    for (const creature of this.creatures) {
      creature.update(elapsed);
      for (const particle of creature.cachedParticles) {
        this.particles.push(particle);
      }
      creature.cachedParticles = [];
      if (creature.shouldDisposeOf) {
        creature.removeFromTiles(this);
        creatureDead = true;
        creature.clear3DData();
        if (!creature.player && creature.exp > 0) {
          this.awardEXPFor_(creature);
        }
        if (creature.deathLedgerId) {
          this.deathLedger.add(creature.deathLedgerId);
        }
      }
    }
    if (creatureDead) {
      this.creatures = this.creatures.filter((cr) => !cr.shouldDisposeOf);
    }

    let particleDead = false;
    for (const particle of this.particles) {
      particle.update(elapsed, this);
      if (particle.dead) {
        particleDead = true;
        particle.clear3DData();
      }
    }
    if (particleDead) {
      this.particles = this.particles.filter((pr) => !pr.dead);
    }

    for (const tile of this.visibleTiles) {
      tile.update(elapsed);
      for (const particle of tile.cachedParticles) {
        this.particles.push(particle);
      }
    }
  }

  /** @param {!Creature} creature */
  addCreature(creature) {
    this.creatures.push(creature);
    creature.addToTiles(this);
  }

  /**
   * @param {number} x
   * @param {number} y
   * @return {?GameMapTile}
   */
  tileAt(x, y) {
    const gameMap = this.gameMapAt(x, y);
    return gameMap ? gameMap.tileAt(x, y) : null;
  }

  /**
   * @param {number} x
   * @param {number} y
   * @return {?GameMap}
   */
  gameMapAt(x, y) {
    return this.gameMaps.get(this.overworldIFor_(x, y));
  }

  /**
   * @param {number} x
   * @param {number} y
   * @return {number}
   * @private
   */
  overworldIFor_(x, y) {
    const size = mapGameMapSize * mapTileUpscale * mapSecondTileUpscale;
    return toI(Math.floor(x / size), Math.floor(y / size));
  }

  /**
   * Makes sure that the map that corresponds to the player position and all
   * nearby maps, are all in memory. All other maps unload.
   */
  reloadMaps() {
    const overworldTileI = this.overworldIFor_(this.active.x, this.active.y);
    const overworldTile = this.overworldMap.tiles.get(overworldTileI);
    if (!overworldTile) return; // Huh?

    const desiredMapIs = new Set();
    desiredMapIs.add(toI(overworldTile.x, overworldTile.y));
    for (const i of overworldTile.doorIds.keys()) {
      desiredMapIs.add(i);
    }

    // Unload any maps that are no longer necessary.
    for (const i of this.gameMaps.keys()) {
      if (desiredMapIs.has(i)) continue;
      const gameMap = this.gameMaps.get(i);
      this.saveGameMap_(gameMap);
      for (const tile of gameMap.tiles.values()) {
        // Avoid memory leaks by disposing of any generated 3D data.
        tile.clear3DData();
      }
      this.gameMaps.delete(i);
      // Unload any creatures in this map.
      this.creatures = this.creatures.filter((creature) => {
        if (this.overworldIFor_(creature.x, creature.y) == i) {
          creature.clear3DData();
          return false;
        }
        return true;
      });
    }

    // Load any maps that are needed but we do not have yet.
    for (const i of desiredMapIs) {
      if (this.gameMaps.has(i)) continue;
      this.loadGameMap(i);
    }
  }

  /**
   * @param {!THREE.Scene} scene
   * @param {!THREE.PerspectiveCamera} camera
   */
  draw(scene, camera) {
    const cX = this.active.cX;
    const cY = this.active.cY;
    const cZ = 0.25;
    const cameraDistance = 2.5;
    camera.position.set(
        cX - Math.cos(this.cameraAngle) * cameraDistance,
        cZ + cameraDistance,
        cY - Math.sin(this.cameraAngle) * cameraDistance);
    camera.lookAt(cX, cZ, cY);

    if (this.dynamicMeshGroup.parent != scene) scene.add(this.dynamicMeshGroup);
    if (this.staticMeshGroup.parent != scene) scene.add(this.staticMeshGroup);
    if (this.lightGroup.parent != scene) scene.add(this.lightGroup);

    // Add light sources in the camera position.
    this.lightGroup.clear();
    const centerTile = this.tileAt(
        Math.floor(this.active.cX), Math.floor(this.active.cY));
    if (centerTile && centerTile.lightingIntensity < 0.6) {
      this.lightGroup.add(gfx.makeLight(cX, cY, cZ, 1, 5)); // Personal.
    }
    for (const gameMap of this.gameMaps.values()) {
      gameMap.addAmbientLight(this.lightGroup);
    }

    // Determine what tiles should be drawn.
    this.visibleTiles.clear();
    const r = 5; // TODO: get?
    for (let y = cY - r; y <= cY + r; y++) {
      for (let x = cX - r; x <= cX + r; x++) {
        const tile = this.tileAt(Math.floor(x), Math.floor(y));
        if (!tile) continue;
        this.visibleTiles.add(tile);
        tile.calculateScreenSpaceCorners(camera);
      }
    }

    // Add creatures and such to the mesh group.
    this.dynamicMeshGroup.clear();
    const alreadyAddedCreatures = new Set();
    for (const tile of this.visibleTiles) {
      for (const creature of tile.creatures) {
        if (alreadyAddedCreatures.has(creature)) continue;
        creature.addToGroup(this.dynamicMeshGroup, camera, this.inCombat);
        alreadyAddedCreatures.add(creature);
      }
    }

    // Add particles to the mesh group.
    for (const particle of this.particles) {
      particle.addToGroup(this.dynamicMeshGroup, this.lightGroup, camera);
    }

    // Discover all visible tiles.
    for (const tile of this.visibleTiles) {
      const gameMap = this.gameMapAt(tile.x, tile.y);
      if (!gameMap) continue;
      gameMap.discoveredTileIs.add(toI(tile.x, tile.y));
    }

    // Add the visible tiles to the scene.
    this.staticMeshGroup.clear();
    for (const tile of this.visibleTiles) {
      tile.addToGroup(this.staticMeshGroup, this, camera);
    }
  }
}
